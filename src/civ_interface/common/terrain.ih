#ifndef FC__TERRAIN_INLINE_H
#define FC__TERRAIN_INLINE_H

#include "shared.h"

#include "fc_types.h"

#include "unittype.h"
#include "game.h"

extern struct terrain civ_terrains[MAX_NUM_TERRAINS];
extern struct resource civ_resources[MAX_NUM_RESOURCES];

/* General terrain accessor functions. */
//[SB] Terrain_type_id terrain_count(void);
static inline Terrain_type_id terrain_count(void)
{
  return game.control.terrain_count;
}

//[SB] Terrain_type_id terrain_index(const struct terrain *pterrain);
static inline Terrain_type_id terrain_index(const struct terrain *pterrain)
{
  assert(pterrain);
  return pterrain - civ_terrains;
}

//[SB] Terrain_type_id terrain_number(const struct terrain *pterrain);
static inline Terrain_type_id terrain_number(const struct terrain *pterrain)
{
  assert(pterrain);
  return pterrain->item_number;
}

//[SB] char terrain_identifier(const struct terrain *pterrain);
static inline char terrain_identifier(const struct terrain *pterrain)
{
  assert(pterrain);
  return pterrain->identifier;
}


/* General resource accessor functions. */
//[SB] Resource_type_id resource_count(void);
static inline Resource_type_id resource_count(void)
{
  return game.control.resource_count;
}

//[SB] Resource_type_id resource_index(const struct resource *presource);
static inline Resource_type_id resource_index(const struct resource *presource)
{
  assert(presource);
  return presource - civ_resources;
}

//[SB] Resource_type_id resource_number(const struct resource *presource);
static inline Resource_type_id resource_number(const struct resource *presource)
{
  assert(presource);
  return presource->item_number;
}


//[SB] struct resource *resource_by_number(const Resource_type_id id);
static inline struct resource *resource_by_number(const Resource_type_id type)
{
  if (type < 0 || type >= game.control.resource_count) {
    /* This isnt an error; some callers depend on it. */
    return NULL;
  }
  return &civ_resources[type];
}

//[SB] void set_special(bv_special *set, enum tile_special_type to_set);
static inline void set_special(bv_special *set, enum tile_special_type to_set)
{
  assert(to_set >= 0 && to_set < S_LAST);
  BV_SET(*set, to_set);
}

//[SB] void clear_special(bv_special *set, enum tile_special_type to_clear);
static inline void clear_special(bv_special *set, enum tile_special_type to_clear)
{
  assert(to_clear >= 0 && to_clear < S_LAST);
  BV_CLR(*set, to_clear);
}

//[SB] void clear_all_specials(bv_special *set);
static inline void clear_all_specials(bv_special *set)
{
  BV_CLR_ALL(*set);
}

//[SB] bool contains_special(bv_special all, enum tile_special_type to_test_for);
static inline bool contains_special(bv_special set, enum tile_special_type to_test_for)
{
  assert(to_test_for >= 0 && to_test_for < S_LAST);
  return BV_ISSET(set, to_test_for);
}

//[SB] bool contains_any_specials(bv_special all);
static inline bool contains_any_specials(bv_special set)
{
  return BV_ISSET_ANY(set);
}


/* Initialization and iteration */
//[SB] struct resource *resource_array_first(void);
static inline struct resource *resource_array_first(void)
{
  if (game.control.resource_count > 0) {
    return civ_resources;
  }
  return NULL;
}

//[SB] const struct resource *resource_array_last(void);
static inline const struct resource *resource_array_last(void)
{
  if (game.control.resource_count > 0) {
    return &civ_resources[game.control.resource_count - 1];
  }
  return NULL;
}


#endif
